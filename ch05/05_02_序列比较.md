

### 序列是否相等或匹配

有 4 个版本的 equal() 算法，其中两个用 == 运算符来比较元素，另外两个用函数对象作为参数来比较元素。

所有指定序列的迭代器都必须至少是输入迭代器。

用 == 运算符的其中一个版本期望 4 个参数: 第一个序列的开始和结束迭代顺，第二个序列的开始和结束迭代器，如果两个序列的长度不同，那么结果总是为 false 。这个版本也是推荐使用的版本。

尽管可以用 equal() 来比较两个同种类型的容器的全部内容，但最好还是使用容器的成员函数 operator==() 来做这些事。

[equal谓词用法示例](05_容器算法/05_02_equal.cpp)


### 查找序列的不同之处

equal() 算法可以判断两个序列是否匹配，而 mismatch() 算法除了可以判断是否匹配之外，如果不匹配，还可以确定不匹配的位置。

与 equal() 相似，mismatch() 也有 4 个版本，也使用方式也与前者一致。

[mismatch谓词用法示例](05_容器算法/05_02_mismatch.cpp)


### 按字典序比较序列

lexicographical_compare() 算法可以比较由开始和结束迭代器定义的两个序列。

它的前两个参数定义了第一个序列，后面两个参数定义了第二个序列。默认使用 < 运算符来比较元素，也可以提供一个函数对象作为可选的第 5 个参数。

[lexicographical_compare谓词用法示例](05_容器算法/05_02_equal.cpp)


### 序列的排列

对于包含相同元素的序列来说，如果一个序列中的元素顺序不同，就是一种排列。

next_permutation() 会生成一个序列的重排列，它是所有可能的字典序中的下一个排列。

next_permutation() 的参数为定义序列的迭代器，其返回值为布尔值。默认使用 < 运算符进行比较，在下一个排列大于上一个排列时返回 true，如果上一个排列是序列中最大的，就返回 false 。

[next_permutation用法示例](05_容器算法/05_02_next_permutation.cpp)

给定一个序列的初始排列，从它开始仅通过调用 next_permutation() 未必能得到该序列的全排列，因为该序列的初始排列未必是最小的排列序列。

当一个排列中的每个元素都小于或等于它后面的元素时，它就是元素序列的最小排列。可以用 min_element() 算法来返回一个指向序列中最小元素的迭代器，然后用 iter_swap() 算法交换两个迭代器指向的元素，从而生成最小的排列。然后以这个最小排列作为起点，通过 next_permutation() 来生成该序列的全排列。

next_permutation() 可以通过改变第三个参数来改变默认规则，比如按 > 运算符进行比较，此时 min_element() 相应改为 max_element() 。

[生成全排列用法示例](05_容器算法/05_02_full_permutation.cpp)

prev_permutation() 以升序的方式生成全排列。

[通过prev_permutation生成全排列用法示例](05_容器算法/05_02_prev_permutation.cpp)
