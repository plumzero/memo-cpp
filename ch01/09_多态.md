
### 多态机制

指向派生类的指针与指向基类的指针，是类型兼容的。而多态机制使这一特性更加强大。多态机制是 C++ 面向对象程序设计语言的另一重要组成部分。

多态性原理如下:

当类型至少有一个虚函数时，
- 编译器为每个类型生成一个虚函数表(vtable)，该表存储了该类全部虚函数的地址。
- 编译器为每个类对象增加一个虚函数表指针(vptr)，该指针存储在对象内存的最开始 8 个字节，并指向该对象类型的虚函数表。

C++ 中可以通过两种方式实现多态机制: 虚成员函数和抽象类。

### 虚成员函数

虚成员函数是指在派生类中可以进行重定义的基类成员函数，通过关键字 virtual 声明:
```c++
class Polygon
{
protected:
  int width, height;
public:
  void set_value(int a, int b) { width = a; height = b; }
  virtual int area() { return 0; }
};

class Rectangle : public Polygon
{
public:
  int area() { return width * height; }
};

class Triangle : public Polygon
{
public:
  int area() { return (width * height) / 2; }
  int just_for_triangle() { std::cout << "Triangle" << std::endl; }
};

// main
Rectangle rect;
Triangle trgl;
Polygon poly;
Polygon* ppoly1 = &rect;
Polygon* ppoly2 = &trgl;
Polygon* ppoly3 = &poly;
ppoly1->set_value(4, 5);
ppoly2->set_value(4, 5);
ppoly3->set_value(4, 5);
std::cout << ppoly1->area() << std::endl;
std::cout << ppoly2->area() << std::endl;
std::cout << ppoly3->area() << std::endl;
// ppoly2->just_for_triangle();     // error
```

虽然基类的非虚函数成员，比如上例中的 set_value，也可以在派生类中重定义，但是在派生类中重定义的这些非虚函数成员无法通过基类指针进行访问。而如果将基类 Polygon 中 area 成员函数的 virtual 去掉，则上述程序返回结果均为 0。

注意: 多态机制时无法通过基类指针访问派生类中新定义(基类中并未出现其定义)的成员，如上例 Triangle 的成员函数 just_for_triangle 是不能通过基类指针 ppoly2 进行访问的。

[程序](t/09_virtual_member_func.cpp)

### 抽象类

抽象类通过在类中定义一个纯虚函数实现，示例如下:
```c++
class Polygon
{
protected:
  int width, height;
public:
  void set_value(int a, int b) { width = a; height = b; }
  virtual int area() = 0;
};
```
抽象类允许有自己的成员变量和非纯虚函数，但抽象类无法被实例化。

### virtual 析构函数

在继承关系中，基类的析构函数应该被声明为 virtual, 否则在 delete 基类指针时将无法访问到派生类的析构函数。
