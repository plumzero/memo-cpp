
*回过头来才发现，虽然看似不可思议，但思考后却是理所应当...*

### 构造和析构顺序

构造函数按照成员在类中声明的顺序执行初始化，而不是按这些成员在初始式表中出现的顺序。

成员的构造函数将在容器类本身的构造函数执行之前首先被执行。

如果某个类对象中包含着一些类对象，当该对象被销毁时，它自己的析构函数(如果有的话)将首先执行，而后将按照与声明相反的顺序执行各个成员的析构函数。

一组局部变量的析构函数将按构造它们的相反顺序执行。


### 调用到拷贝构造函数的 4 种情况

1. 将对象作为初始化值。注意，对一个已声明对象的赋值操作并不会调用到拷贝构造函数。
2. 将对象作为函数的参数。会涉及到临时对象的创建，因此也会调用到拷贝构造函数。
3. 作为函数的返回值，同上。
4. 作为一个异常。


### 派生类的构造与析构

派生类的构造函数只能描述它自己的成员和自己的直接基类的初始式，不能直接去初始化基类的成员。
```c++
    Employee::Employee(const string& n, int d) : family_name(n), department(d) {
        // ...
    }
    Manager::Manager(const string& n, int d, int lvl) : Employee(n, d), level(lvl) {
        // ...
    }
```

赋值运算符是不继承的，构造函数也是不继承的。

派生类的构造顺序和析构顺序
+ 类对象的构造是自下而上进行的: 首先是基类，而后是成员，再后才是派生类本身。
+ 类对象的销毁则正好以相反的顺序进行: 首先是派生类本身，而后是成员，再后才是基类。


### 类的 static 成员

在 C++ 中，除了传统定义全局变量和全局函数的方法外(使用 `extern`)，还可以通过 `static` 声明将一个变量或函数声明(不能初始化)在类中来实现全局的目的。

static 成员与该类的其他普通成员有以下区别:
+ static 变量不属于这个类实例化后的任一对象(可以通过 sizeof 判断);
+ static 函数里没有 this 指针。

和普通的全局函数相比，static 成员有以下特点:
+ 受 public/private 限制;
+ 可以自由访问类的其他成员。

static 成员在类中的应用
+ 类的实例计数
+ 单例模式


### 复制与切割

```c++
    void f(const Manager& m) {
        Employee e = m;     // 从 m 的 Employee 部分创建 e
        e = m;              // 从 m 的 Employee 部分给 e 赋值 
    }
```
此处只有 Manager 的 Employee 部分被复制，称这种情况为切割。

在类层次结构中传递类对象的指针或引用，其中的一个原因就是为了避免切割问题。另外的一个原因是为了维持多态性行为和保证效率。
