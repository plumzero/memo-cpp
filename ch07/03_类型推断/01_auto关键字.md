

auto 是一种隐式类型推导。不同于许多动态类型语言的运行时变量类型推导，隐式类型定义的类型推导发生在编译器。也就是说，在 C++ 中使用类型推导，并不会产生运行效率上的损失。

auto 并不能代表一个实际的类型声明，只是一个类型声明的占位符。所以使用 auto 声明的变量必须马上初始化，以让编译器推断出的它的实际类型，并在编译时将 auto 占位符替换为真正的类型。

### 推导规则说明

- 对于普通类型推断(没有 const 属性并且也不掺杂引用的)，直接根据表达式右边值的类型进行推断。注意必须有初始值。
  ```c++
    auto x = 123; // auto 被推断为 int 类型
  ```
- 使用引用进行推断，实际上就是使用引用对象的类型进行推断。此时引用特性会被丢弃，如果定义的对象需要成为引用，那么需要自己在 auto 后面加上 & 来定义对象。
  ```c++
    int x = 0, &rx = x;
    auto a1 = rx; // auto 被推断为 int 类型
    auto& a2 = rx; // auto 被推断为 int 类型，a2 对象本身就是 int& 类型
  ```
- 使用带有 const 属性的对象进行推断时，对于指针或者引用，const 属性会保留。其他则丢弃。
  ```c++
    const int c = 10;
    auto a1 = c;  // auto 被推断为 int 类型
    auto& a2 = c; // auto 被推断为 const int

    const char arr[] = "Hello World";
    auto r1 = arr;  // auto 被推断为 const char*
  ```

### 适用场景

一些类型长度书写很长的，比如 lambda 表达式类型。

auto 常用于推导模板容器中迭代器类型。

### 不适用场景

C++11 中使用 auto 有如下限制:
- 不能用于函数参数
- 不能用于非静态成员变量
- 无法定义数组
- 无法推导出模板参数

[auto使用示例](t/01_auto.cpp)
